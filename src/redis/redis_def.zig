const std = @import("std");

pub const SIMPLE_STRING_PREFIX = '+';
pub const STRING_PREFIX = '$';
pub const ARRAY_PREFIX = '*';
pub const ERROR_PREFIX = '-';
pub const INT_PREFIX = ':';

pub const LF = '\n';
pub const CR = '\r';
pub const CRLF = "\r\n";

pub const DataType = enum {
    SimpleString,
    String,
    Error,
    Int,
    Array,
};

pub const ValueType = enum {
    String,
    Int,
};

pub const Value = struct { typ: DataType, val: union {
    string: []u8,
} };

pub const Command = enum {
    append,
    auth,
    bgrewriteaof,
    bgsave,
    bitcount,
    bitfield,
    bitop,
    bitpos,
    blpop,
    brpop,
    brpoplpush,
    bzpopmax,
    bzpopmin,
    client,
    cluster,
    command,
    config,
    dbsize,
    debug,
    decr,
    decrby,
    del,
    discard,
    dump,
    echo,
    eval,
    evalsha,
    exec,
    exists,
    expire,
    expireat,
    flushall,
    flushdb,
    geoadd,
    geodecode,
    geodist,
    geoencode,
    geohash,
    geopos,
    georadius,
    georadiusbymember,
    get,
    getbit,
    getrange,
    getset,
    hdel,
    hexists,
    hget,
    hgetall,
    hincrby,
    hincrbyfloat,
    hkeys,
    hlen,
    hmget,
    hmset,
    hscan,
    hset,
    hsetnx,
    hstrlen,
    hvals,
    incr,
    incrby,
    incrbyfloat,
    info,
    keys,
    lastsave,
    lindex,
    linsert,
    llen,
    lpop,
    lpush,
    lpushx,
    lrange,
    lrem,
    lset,
    ltrim,
    memory,
    mget,
    migrate,
    monitor,
    move,
    mset,
    msetnx,
    multi,
    object,
    persist,
    pexpire,
    pexpireat,
    pfadd,
    pfcount,
    pfmerge,
    ping,
    psetex,
    psubscribe,
    pttl,
    publish,
    pubsub,
    punsubscribe,
    quit,
    randomkey,
    readonly,
    readwrite,
    rename,
    renamenx,
    replicaof,
    restore,
    role,
    rpop,
    rpoplpush,
    rpush,
    rpushx,
    sadd,
    save,
    scan,
    scard,
    script,
    sdiff,
    sdiffstore,
    select,
    set,
    setbit,
    setex,
    setnx,
    setrange,
    shutdown,
    sinter,
    sinterstore,
    sismember,
    slaveof,
    slowlog,
    smembers,
    smove,
    sort,
    spop,
    srandmember,
    srem,
    sscan,
    strlen,
    subscribe,
    sunion,
    sunionstore,
    swapdb,
    sync,
    time,
    touch,
    ttl,
    type,
    unlink,
    unsubscribe,
    unwatch,
    wait,
    watch,
    xack,
    xadd,
    xclaim,
    xdel,
    xgroup,
    xinfo,
    xlen,
    xpending,
    xrange,
    xread,
    xreadgroup,
    xrevrange,
    xtrim,
    zadd,
    zcard,
    zcount,
    zincrby,
    zinterstore,
    zlexcount,
    zpopmax,
    zpopmin,
    zrange,
    zrangebylex,
    zrangebyscore,
    zrank,
    zrem,
    zremrangebylex,
    zremrangebyrank,
    zremrangebyscore,
    zrevrange,
    zrevrangebylex,
    zrevrangebyscore,
    zrevrank,
    zscan,
    zscore,
    zunionstore,
};

pub const ClientCommand = enum { id, kill, list, pause, reply, setname, unblock };

// pub fn EnumStruct(comptime T: type, comptime TValue: type, comptime default_value: TValue) type {
//     switch (@typeInfo(T)) {
//         .Enum => {
//             const fields = std.meta.fields(T);

//             var struct_fields: [fields.len]std.builtin.Type.StructField = undefined;

//             inline for (fields, 0..) |f, i| {
//                 struct_fields[i] = .{ .name = f.name, .type = TValue, .default_value = &default_value, .alignment = 0, .is_comptime = false };
//             }

//             const type_info: std.builtin.Type = .{
//                 .Struct = .{
//                     .layout = .auto,
//                     .is_tuple = false,
//                     .decls = &.{},

//                     // array of fields, one field per enum value
//                     .fields = &struct_fields,
//                 },
//             };

//             return @Type(type_info);
//         },

//         else => {
//             @compileError("EnumStruct only supports enums as the first argument");
//         },
//     }
// }
